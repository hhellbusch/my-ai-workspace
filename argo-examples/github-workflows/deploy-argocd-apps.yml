name: Deploy ArgoCD Applications

on:
  push:
    branches:
      - main
    paths:
      - 'charts/argocd-apps/**'  # Helm chart changes
      - 'apps/**'                # Application changes
      - 'infrastructure/**'      # Infrastructure changes
      - 'hubs.yaml'              # Cluster configuration changes
  workflow_dispatch:  # Allow manual trigger

# Prevent concurrent deployments to avoid conflicts
concurrency:
  group: deploy-argocd-apps
  cancel-in-progress: false  # Queue new runs instead of canceling

jobs:
  deploy-argocd-apps:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Fail if deployment takes longer than 30 minutes
    
    # Explicit permissions (principle of least privilege)
    permissions:
      contents: read      # Read repository contents
      actions: read       # Read workflow artifacts

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install OpenShift CLI
        uses: redhat-actions/oc-installer@v1
        with:
          oc_version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Generate directory lists for Helm values
        run: |
          # Reusable function to discover directories and convert to JSON array
          get_directories_as_json() {
            local path=$1
            local label=$2

            # Get list of directories (excluding hidden directories)
            local dirs=$(find ${path} -mindepth 1 -maxdepth 1 -type d -not -path '*/\.*' -exec basename {} \; | sort)

            # Convert to JSON array format
            local json_array=$(echo "$dirs" | jq -R -s -c 'split("\n") | map(select(length > 0))')

            echo "Discovered ${label} directories: $json_array"
            echo "$json_array"
          }

          # Discover applications
          APP_ARRAY=$(get_directories_as_json "./apps" "application")
          echo "APP_DIRECTORIES=$APP_ARRAY" >> $GITHUB_ENV

          # Discover infrastructure
          INFRA_ARRAY=$(get_directories_as_json "./infrastructure" "infrastructure")
          echo "INFRA_DIRECTORIES=$INFRA_ARRAY" >> $GITHUB_ENV

      - name: Deploy to all clusters
        env:
          # Add all your cluster tokens as secrets here
          OPENSHIFT_TOKEN_DEV: ${{ secrets.OPENSHIFT_TOKEN_DEV }}
          OPENSHIFT_TOKEN_STAGING: ${{ secrets.OPENSHIFT_TOKEN_STAGING }}
          OPENSHIFT_TOKEN_PROD: ${{ secrets.OPENSHIFT_TOKEN_PROD }}
        run: |
          # Read the number of clusters from hubs.yaml
          CLUSTER_COUNT=$(yq eval '.clusters | length' hubs.yaml)

          echo "Found $CLUSTER_COUNT clusters to deploy to"

          # Loop through each cluster
          for i in $(seq 0 $(($CLUSTER_COUNT - 1))); do
            # Extract cluster information
            CLUSTER_NAME=$(yq eval ".clusters[$i].name" hubs.yaml)
            CLUSTER_SERVER=$(yq eval ".clusters[$i].server" hubs.yaml)
            ARGOCD_NAMESPACE=$(yq eval ".clusters[$i].argocd_namespace" hubs.yaml)
            TOKEN_SECRET=$(yq eval ".clusters[$i].token_secret" hubs.yaml)

            echo "================================================"
            echo "Deploying to cluster: $CLUSTER_NAME"
            echo "Server: $CLUSTER_SERVER"
            echo "ArgoCD Namespace: $ARGOCD_NAMESPACE"
            echo "================================================"

            # Enable error tracking for this cluster
            set -e
            set -o pipefail
            
            # Function to handle errors
            handle_error() {
              local exit_code=$?
              echo "================================================"
              echo "❌ ERROR: Deployment to $CLUSTER_NAME failed with exit code $exit_code"
              echo "Last command: $BASH_COMMAND"
              echo "================================================"
              echo "Cleaning up..."
              oc logout 2>/dev/null || true
              exit $exit_code
            }
            
            trap handle_error ERR

            # Get the token value from the environment variable
            TOKEN_VALUE=$(eval echo \$${TOKEN_SECRET})

            if [ -z "$TOKEN_VALUE" ]; then
              echo "ERROR: Token secret $TOKEN_SECRET is not set in GitHub secrets"
              exit 1
            fi

            # Authenticate to the cluster (with timeout)
            echo "Authenticating to $CLUSTER_NAME..."
            timeout 60 oc login --token="${TOKEN_VALUE}" --server="${CLUSTER_SERVER}" --insecure-skip-tls-verify=true || {
              echo "ERROR: Login to $CLUSTER_NAME timed out after 60 seconds"
              exit 1
            }

            # Template the Helm chart and apply to the cluster
            echo "Applying ArgoCD applications..."
            helm template argocd-apps ./charts/argocd-apps \
              --namespace ${ARGOCD_NAMESPACE} \
              --set-json "applications=$APP_DIRECTORIES" \
              --set-json "infrastructure=$INFRA_DIRECTORIES" \
              | timeout 120 oc apply -f -

            echo "Verifying ArgoCD applications created..."
            oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app

            # Health check: Wait for applications to sync (warning only)
            echo "Checking application health status..."
            HEALTH_TIMEOUT=300  # 5 minutes
            HEALTH_ELAPSED=0
            ALL_HEALTHY=false

            while [ $HEALTH_ELAPSED -lt $HEALTH_TIMEOUT ]; do
              # Check only applications managed by root-app (created by this deployment)
              if command -v jq &> /dev/null; then
                UNHEALTHY_COUNT=$(oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app -o json 2>/dev/null | \
                  jq '[.items[] | select(.status.sync.status != "Synced" or .status.health.status != "Healthy")] | length' || echo "0")
                
                if [ "$UNHEALTHY_COUNT" -eq 0 ]; then
                  echo "✅ All deployed applications are synced and healthy"
                  ALL_HEALTHY=true
                  break
                fi
                
                echo "⏳ Waiting for $UNHEALTHY_COUNT applications to become healthy... (${HEALTH_ELAPSED}s/${HEALTH_TIMEOUT}s)"
              else
                echo "⚠️  jq not available, skipping detailed health check"
                break
              fi
              
              sleep 15
              HEALTH_ELAPSED=$((HEALTH_ELAPSED + 15))
            done

            if [ "$ALL_HEALTHY" = false ]; then
              echo "⚠️  Warning: Some applications are not healthy after ${HEALTH_TIMEOUT}s"
              echo "This is not a failure - ArgoCD may still be syncing applications."
              echo ""
              echo "Application statuses:"
              if command -v jq &> /dev/null; then
                oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app -o json 2>/dev/null | \
                  jq -r '.items[] | "  \(.metadata.name): Sync=\(.status.sync.status // "Unknown") Health=\(.status.health.status // "Unknown")"' || \
                  oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app
              else
                oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app
              fi
              echo ""
              # Uncomment the line below to make health check failures halt the deployment:
              # exit 1
            fi

            # Logout from the cluster
            echo "Logging out from $CLUSTER_NAME..."
            oc logout 2>/dev/null || true
            
            # Clear error trap for next iteration
            trap - ERR
            set +e
            set +o pipefail

            echo "✅ Successfully deployed to $CLUSTER_NAME"
            echo ""
          done

          echo "================================================"
          echo "✅ All clusters deployed successfully!"
          echo "================================================"
