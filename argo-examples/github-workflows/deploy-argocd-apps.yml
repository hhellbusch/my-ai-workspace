name: Deploy ArgoCD Applications

on:
  push:
    branches:
      - main
    paths:
      - 'charts/argocd-apps/**'  # Helm chart changes
      - 'apps/**'                # Application changes
      - 'infrastructure/**'      # Infrastructure changes
      - 'hubs.yaml'              # Cluster configuration changes
  workflow_dispatch:  # Allow manual trigger
    inputs:
      dry_run:
        description: 'Run in dry-run mode (preview changes without applying)'
        required: false
        type: boolean
        default: false

# Prevent concurrent deployments to avoid conflicts
concurrency:
  group: deploy-argocd-apps
  cancel-in-progress: false  # Queue new runs instead of canceling

jobs:
  deploy-argocd-apps:
    runs-on: ubuntu-latest
    timeout-minutes: 30  # Fail if deployment takes longer than 30 minutes
    
    # Explicit permissions (principle of least privilege)
    permissions:
      contents: read      # Read repository contents
      actions: read       # Read workflow artifacts

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install OpenShift CLI
        uses: redhat-actions/oc-installer@v1
        with:
          oc_version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version

      - name: Generate directory lists for Helm values
        run: |
          # Reusable function to discover directories and convert to JSON array
          get_directories_as_json() {
            local path=$1
            local label=$2

            # Get list of directories (excluding hidden directories)
            local dirs=$(find ${path} -mindepth 1 -maxdepth 1 -type d -not -path '*/\.*' -exec basename {} \; | sort)

            # Convert to JSON array format
            local json_array=$(echo "$dirs" | jq -R -s -c 'split("\n") | map(select(length > 0))')

            echo "Discovered ${label} directories: $json_array"
            echo "$json_array"
          }

          # Discover applications
          APP_ARRAY=$(get_directories_as_json "./apps" "application")
          echo "APP_DIRECTORIES=$APP_ARRAY" >> $GITHUB_ENV

          # Discover infrastructure
          INFRA_ARRAY=$(get_directories_as_json "./infrastructure" "infrastructure")
          echo "INFRA_DIRECTORIES=$INFRA_ARRAY" >> $GITHUB_ENV

      - name: Deploy to all clusters
        env:
          # Add all your cluster tokens as secrets here
          OPENSHIFT_TOKEN_DEV: ${{ secrets.OPENSHIFT_TOKEN_DEV }}
          OPENSHIFT_TOKEN_STAGING: ${{ secrets.OPENSHIFT_TOKEN_STAGING }}
          OPENSHIFT_TOKEN_PROD: ${{ secrets.OPENSHIFT_TOKEN_PROD }}
        run: |
          # Read the number of clusters from hubs.yaml
          CLUSTER_COUNT=$(yq eval '.clusters | length' hubs.yaml)

          echo "Found $CLUSTER_COUNT clusters to deploy to"

          # Loop through each cluster
          for i in $(seq 0 $(($CLUSTER_COUNT - 1))); do
            # Extract cluster information
            CLUSTER_NAME=$(yq eval ".clusters[$i].name" hubs.yaml)
            CLUSTER_SERVER=$(yq eval ".clusters[$i].server" hubs.yaml)
            ARGOCD_NAMESPACE=$(yq eval ".clusters[$i].argocd_namespace" hubs.yaml)
            TOKEN_SECRET=$(yq eval ".clusters[$i].token_secret" hubs.yaml)
            
            # Determine dry-run mode (hybrid approach)
            CLUSTER_DRY_RUN=$(yq eval ".clusters[$i].dry_run // false" hubs.yaml)
            WORKFLOW_DRY_RUN="${{ inputs.dry_run || 'false' }}"
            
            # Either workflow input OR cluster config triggers dry-run
            if [ "$WORKFLOW_DRY_RUN" = "true" ] || [ "$CLUSTER_DRY_RUN" = "true" ]; then
              DRY_RUN=true
              DRY_RUN_REASON=""
              [ "$WORKFLOW_DRY_RUN" = "true" ] && DRY_RUN_REASON="workflow input"
              [ "$CLUSTER_DRY_RUN" = "true" ] && [ -n "$DRY_RUN_REASON" ] && DRY_RUN_REASON="$DRY_RUN_REASON + cluster config" || [ "$CLUSTER_DRY_RUN" = "true" ] && DRY_RUN_REASON="cluster config"
            else
              DRY_RUN=false
            fi

            echo "================================================"
            echo "Deploying to cluster: $CLUSTER_NAME"
            echo "Server: $CLUSTER_SERVER"
            echo "ArgoCD Namespace: $ARGOCD_NAMESPACE"
            if [ "$DRY_RUN" = "true" ]; then
              echo "Mode: ðŸ” DRY-RUN (reason: $DRY_RUN_REASON)"
            else
              echo "Mode: âœ… APPLY"
            fi
            echo "================================================"

            # Enable error tracking for this cluster
            set -e
            set -o pipefail
            
            # Function to handle errors
            handle_error() {
              local exit_code=$?
              echo "================================================"
              echo "âŒ ERROR: Deployment to $CLUSTER_NAME failed with exit code $exit_code"
              echo "Last command: $BASH_COMMAND"
              echo "================================================"
              exit $exit_code
            }
            
            trap handle_error ERR

            # Get the token value from the environment variable
            TOKEN_VALUE=$(eval echo \$${TOKEN_SECRET})

            if [ -z "$TOKEN_VALUE" ]; then
              echo "ERROR: Token secret $TOKEN_SECRET is not set in GitHub secrets"
              exit 1
            fi

            # Authenticate to the cluster (with timeout)
            echo "Authenticating to $CLUSTER_NAME..."
            timeout 60 oc login --token="${TOKEN_VALUE}" --server="${CLUSTER_SERVER}" --insecure-skip-tls-verify=true || {
              echo "ERROR: Login to $CLUSTER_NAME timed out after 60 seconds"
              exit 1
            }

            # Template the Helm chart and apply/preview based on mode
            if [ "$DRY_RUN" = "true" ]; then
              echo "ðŸ” DRY-RUN MODE: Running server-side validation..."
              echo ""
              
              # Generate manifests
              MANIFESTS=$(helm template argocd-apps ./charts/argocd-apps \
                --namespace ${ARGOCD_NAMESPACE} \
                --set-json "applications=$APP_DIRECTORIES" \
                --set-json "infrastructure=$INFRA_DIRECTORIES")
              
              # Save preview for artifacts
              echo "$MANIFESTS" > /tmp/preview-${CLUSTER_NAME}.yaml
              
              # Run server-side dry-run for validation
              echo "Running server-side validation against cluster..."
              if echo "$MANIFESTS" | timeout 120 oc apply --dry-run=server -f - 2>&1 | tee /tmp/dryrun-${CLUSTER_NAME}.log; then
                echo ""
                echo "âœ… Server-side validation PASSED for $CLUSTER_NAME"
                echo ""
                echo "Preview of changes (first 50 lines):"
                echo "================================================"
                head -50 /tmp/preview-${CLUSTER_NAME}.yaml
                echo "================================================"
                echo ""
                echo "ðŸ’¾ Full preview saved to workflow artifacts as 'preview-${CLUSTER_NAME}.yaml'"
                echo "âš ï¸  DRY-RUN: No changes were applied to $CLUSTER_NAME"
              else
                echo ""
                echo "âŒ Server-side validation FAILED for $CLUSTER_NAME"
                echo "Check the logs above for details"
                exit 1
              fi
            else
              echo "Applying ArgoCD applications..."
              helm template argocd-apps ./charts/argocd-apps \
                --namespace ${ARGOCD_NAMESPACE} \
                --set-json "applications=$APP_DIRECTORIES" \
                --set-json "infrastructure=$INFRA_DIRECTORIES" \
                | timeout 120 oc apply -f -
              
              echo "Verifying ArgoCD applications created..."
              oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app
            fi

            # Health check: Wait for applications to sync (warning only, skip in dry-run)
            if [ "$DRY_RUN" = "false" ]; then
              echo "Checking application health status..."
            HEALTH_TIMEOUT=300  # 5 minutes
            HEALTH_ELAPSED=0
            ALL_HEALTHY=false

            while [ $HEALTH_ELAPSED -lt $HEALTH_TIMEOUT ]; do
              # Check only applications managed by root-app (created by this deployment)
              if command -v jq &> /dev/null; then
                UNHEALTHY_COUNT=$(oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app -o json 2>/dev/null | \
                  jq '[.items[] | select(.status.sync.status != "Synced" or .status.health.status != "Healthy")] | length' || echo "0")
                
                if [ "$UNHEALTHY_COUNT" -eq 0 ]; then
                  echo "âœ… All deployed applications are synced and healthy"
                  ALL_HEALTHY=true
                  break
                fi
                
                echo "â³ Waiting for $UNHEALTHY_COUNT applications to become healthy... (${HEALTH_ELAPSED}s/${HEALTH_TIMEOUT}s)"
              else
                echo "âš ï¸  jq not available, skipping detailed health check"
                break
              fi
              
              sleep 15
              HEALTH_ELAPSED=$((HEALTH_ELAPSED + 15))
            done

            if [ "$ALL_HEALTHY" = false ]; then
              echo "âš ï¸  Warning: Some applications are not healthy after ${HEALTH_TIMEOUT}s"
              echo "This is not a failure - ArgoCD may still be syncing applications."
              echo ""
              echo "Application statuses:"
              if command -v jq &> /dev/null; then
                oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app -o json 2>/dev/null | \
                  jq -r '.items[] | "  \(.metadata.name): Sync=\(.status.sync.status // "Unknown") Health=\(.status.health.status // "Unknown")"' || \
                  oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app
              else
                oc get applications -n ${ARGOCD_NAMESPACE} -l managed-by=root-app
              fi
              echo ""
              # Uncomment the line below to make health check failures halt the deployment:
              # exit 1
            fi
            fi  # End of dry-run check

            # Clear error trap for next iteration
            trap - ERR
            set +e
            set +o pipefail

            echo "âœ… Successfully deployed to $CLUSTER_NAME"
            echo ""
          done

          echo "================================================"
          echo "âœ… All clusters deployed successfully!"
          echo "================================================"
      
      - name: Upload dry-run previews
        if: always()  # Upload even if deployment failed
        uses: actions/upload-artifact@v4
        with:
          name: dry-run-previews
          path: /tmp/preview-*.yaml
          retention-days: 30
          if-no-files-found: ignore
